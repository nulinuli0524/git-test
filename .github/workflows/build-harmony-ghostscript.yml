name: Build HarmonyOS Ghostscript Library

on:
  workflow_dispatch:
    inputs:
      ghostscript_version:
        description: 'Ghostscript Version'
        required: false
        default: '10.03.0'
  push:
    branches: [ master ]

env:
  OHOS_NDK_VERSION: "4.0.10.6"
  GHOSTSCRIPT_VERSION: ${{ github.event.inputs.ghostscript_version || '10.03.0' }}
  LIBRARY_NAME: "pdf_converter"
  PROJECT_ROOT: "native-build"

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository (shallow)
      uses: actions/checkout@v4
      with:
        fetch-depth: 1  # 减少磁盘使用

    - name: Free disk space
      run: |
        # 清理系统缓存
        sudo apt-get clean
        sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc
        
        # 清理包管理器缓存
        if command -v npm &> /dev/null; then npm cache clean --force; fi
        if command -v pip &> /dev/null; then pip cache purge; fi
        
        # 删除临时文件
        sudo rm -rf /tmp/* /var/tmp/*
        
        # 检查磁盘空间
        df -h

    - name: Setup directories
      run: |
        mkdir -p ${{ env.PROJECT_ROOT }}
        echo "PROJECT_PATH=$GITHUB_WORKSPACE/${{ env.PROJECT_ROOT }}" >> $GITHUB_ENV

    - name: Setup HarmonyOS NDK
      run: |
        mkdir -p ohos-ndk
        NDK_ZIP="ohos-sdk-linux-public-${{ env.OHOS_NDK_VERSION }}.zip"
        
        # 下载鸿蒙 NDK
        wget "https://repo.huaweicloud.com/harmonyos/sdk/ohos-sdk/$NDK_ZIP" -O $NDK_ZIP
        
        # 解压并设置路径
        unzip $NDK_ZIP -d ohos-ndk
        echo "OHOS_NDK_PATH=$GITHUB_WORKSPACE/ohos-ndk/ohos-sdk/linux/native" >> $GITHUB_ENV
        
        # 清理压缩包
        rm -f $NDK_ZIP

    - name: Download Ghostscript source
      run: |
        # 使用正确的下载 URL
        VERSION="${{ env.GHOSTSCRIPT_VERSION }}"
        GHOSTSCRIPT_URL="https://github.com/ArtifexSoftware/ghostpdl/archive/refs/tags/ghostscript-$VERSION.tar.gz"
        
        echo "下载 URL: $GHOSTSCRIPT_URL"
        
        # 带重试的下载
        for i in {1..3}; do
          if wget $GHOSTSCRIPT_URL -O ghostscript.tar.gz; then
            echo "✅ 下载成功"
            break
          else
            echo "⚠️ 下载失败，尝试 #$i"
            sleep 10
          fi
        done
        
        # 验证下载
        if [ ! -f "ghostscript.tar.gz" ]; then
          echo "❌ 无法下载 Ghostscript 源码"
          exit 1
        fi
        
        # 创建目标目录
        mkdir -p ${{ env.PROJECT_PATH }}/src/main/cpp/ghostscript
        
        # 提取必要的子目录
        tar -xzf ghostscript.tar.gz \
          --strip-components=3 \
          --directory=${{ env.PROJECT_PATH }}/src/main/cpp/ghostscript \
          ghostpdl-ghostscript-$VERSION/ghostscript/base \
          ghostpdl-ghostscript-$VERSION/ghostscript/psi \
          ghostpdl-ghostscript-$VERSION/ghostscript/main \
          ghostpdl-ghostscript-$VERSION/ghostscript/devices
        
        # 验证关键文件
        if [ ! -f "${{ env.PROJECT_PATH }}/src/main/cpp/ghostscript/devices/gdevpclm.c" ]; then
          echo "❌ 文件提取失败！目录内容:"
          find ${{ env.PROJECT_PATH }}/src/main/cpp/ghostscript -type f | head -20
          exit 1
        fi
        
        # 清理
        rm -f ghostscript.tar.gz

    - name: Create CMake project structure
      run: |
        cd ${{ env.PROJECT_PATH }}
        
        # 创建主 CMakeLists.txt
        cat > CMakeLists.txt << 'EOF'
        cmake_minimum_required(VERSION 3.16)
        project(pdf_converter)
        
        # 设置编译参数
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -D__OHOS__ -Wno-deprecated")
        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -D__OHOS__")
        
        # 添加 Ghostscript 子目录
        add_subdirectory(src/main/cpp/ghostscript)
        
        # 创建共享库
        add_library(pdf_converter SHARED src/main/cpp/pdf_converter.cpp)
        
        # 链接库
        target_link_libraries(pdf_converter PUBLIC
            ghostscript
            libace_napi.z.so
            libhilog_ndk.z.so
        )
        
        # 包含目录
        target_include_directories(pdf_converter PRIVATE
            src/main/cpp/ghostscript
        )
        EOF
        
        # 创建 Ghostscript 的 CMakeLists
        mkdir -p src/main/cpp/ghostscript
        cat > src/main/cpp/ghostscript/CMakeLists.txt << 'EOF'
        # 只包含必要的源文件
        file(GLOB_RECURSE GS_SOURCES
            "base/*.c"
            "psi/*.c"
            "main/*.c"
            "devices/gdevpclm.c"  # 只包含 PCLm 设备
        )
        
        add_library(ghostscript STATIC ${GS_SOURCES})
        
        # 鸿蒙特定定义
        target_compile_definitions(ghostscript PRIVATE
            __OHOS__=1
            USE_LARGE_FILES=1
            OPAQUE=1
        )
        
        # 包含目录
        target_include_directories(ghostscript PUBLIC
            ${CMAKE_CURRENT_SOURCE_DIR}
            ${CMAKE_CURRENT_SOURCE_DIR}/base
        )
        EOF
        
        # 创建业务逻辑文件
        mkdir -p src/main/cpp
        cat > src/main/cpp/pdf_converter.cpp << 'EOF'
        #include <napi/native_api.h>
        #include "ghostscript/iapi.h"
        
        static napi_value ConvertPdfToPclm(napi_env env, napi_callback_info info) {
            size_t argc = 2;
            napi_value args[2];
            napi_get_cb_info(env, info, &argc, args, nullptr, nullptr);
            
            // 获取文件路径
            char pdfPath[256], pclmPath[256];
            size_t pathLen;
            napi_get_value_string_utf8(env, args[0], pdfPath, sizeof(pdfPath), &pathLen);
            napi_get_value_string_utf8(env, args[1], pclmPath, sizeof(pclmPath), &pathLen);
            
            // 初始化 Ghostscript
            void *instance;
            int code = gsapi_new_instance(&instance, nullptr);
            if (code < 0) return nullptr;
            
            // 设置转换参数
            const char *argv[] = {
                "ghostscript",
                "-dNOPAUSE", "-dBATCH", "-dQUIET",
                "-sDEVICE=pclm",
                "-dCompressionStrategy=2",
                "-r300",
                "-sOutputFile=", pclmPath,
                pdfPath,
                nullptr
            };
            int argCount = sizeof(argv)/sizeof(char*) - 1;
            
            // 执行转换
            code = gsapi_init_with_args(instance, argCount, (char **)argv);
            gsapi_exit(instance);
            gsapi_delete_instance(instance);
            
            return nullptr;
        }
        
        // 模块初始化
        EXTERN_C_START
        static napi_value Init(napi_env env, napi_value exports) {
            napi_property_descriptor desc = {
                "convertPdfToPclm", nullptr, ConvertPdfToPclm
            };
            napi_define_properties(env, exports, 1, &desc);
            return exports;
        }
        EXTERN_C_END
        
        // 模块注册
        static napi_module pdf_converter_module = {
            .nm_version = 1,
            .nm_register_func = Init,
            .nm_modname = "pdf_converter",
        };
        
        extern "C" __attribute__((constructor)) void RegisterModule() {
            napi_module_register(&pdf_converter_module);
        }
        EOF

    - name: Build with CMake and Ninja
      run: |
        cd ${{ env.PROJECT_PATH }}
        
        # 创建构建目录
        mkdir build && cd build
        
        # 使用 Ninja 构建系统
        cmake .. \
          -G Ninja \
          -DCMAKE_TOOLCHAIN_FILE=${{ env.OHOS_NDK_PATH }}/build/cmake/ohos.toolchain.cmake \
          -DOHOS_ARCH=arm64-v8a \
          -DOHOS_STL=c++_shared \
          -DCMAKE_BUILD_TYPE=MinSizeRel
        
        # 使用 Ninja 构建
        ninja
        
        # 重命名为鸿蒙标准格式
        mv libpdf_converter.so libpdf_converter.z.so
        
        # 清理中间文件
        find . -name "*.o" -delete
        rm -rf CMakeFiles

    - name: Verify output
      run: |
        cd ${{ env.PROJECT_PATH }}/build
        file libpdf_converter.z.so
        ls -lh libpdf_converter.z.so

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: harmony-pdf-converter
        path: ${{ env.PROJECT_PATH }}/build/libpdf_converter.z.so
        compression-level: 0
        overwrite: true
